# -*- coding: utf-8 -*-
"""Program 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15MXT3XWDHnp4ueTb_hR7a9YArLfp4vnx

###"การวิเคราะห์ความสัมพันธ์ระหว่างข้อมูลน้ำฝนกับผลผลิตมังคุต"###
###“Analysis of the relationship between rainfall data and mangosteen production and export volume”###

git
> [Datasets](https://github.com/phatt20/**pro01**)

ชื่อไฟล์ข้อมูลที่ใช้

ผู้วิจัย
1.   64122250029
2.   64122250030
"""

from sklearn.metrics import mean_squared_error, r2_score
import math #นำเข้าฟังก์ชัน mean_squared_error และ r2_score จาก scikit-learn และโมดูล math เพื่อให้สามารถทำการคำนวณทางคณิตศาสตร์ได้

# Evaluate the models
def evaluate_model(y_true, y_pred, model_name): #ฟังก์ชันรับพารามิเตอร์ทั้งหมด 3 ตัว
    r2 = r2_score(y_true, y_pred)   #ตั้งแต่r2 - rmse โค้ดทำการคำนวณ R-squared, Mean Squared Error (MSE), และ Root Mean Squared Error (RMSE) โดยใช้ค่าที่รับเข้ามา
    mse = mean_squared_error(y_true, y_pred)
    rmse = math.sqrt(mse)
    print(f"Model: {model_name}")
    print(f"R-squared: {round(r2,2)}")
    print(f"Mean Square Error: {round(mse,2)}")
    print(f"Root Mean Square Error: {round(rmse,2)}")
    print("") #print โค้ดทำการแสดงผลชื่อโมเดล, R-squared, MSE, และ RMSE ที่มีจุดทศนิยม 2 ตำแหน่ง
    toRe = {
      'modelName' : model_name,
      'r2' : r2,
      'mse' : mse,
      'rmse' : rmse,
    } #toRe โค้ดทำการสร้างพจนานุกรม (toRe) ที่บรรจุชื่อโมเดล, R-squared, MSE, และ RMSE
    return toRe #ฟังก์ชันทำการคืนค่าพจนานุกรมที่บรรจุผลลัพธ์การประเมิน

# Commented out IPython magic to ensure Python compatibility.
#Import Library
import numpy as np #ไลบรารีที่ให้ฟังก์ชันทางคณิตศาสตร์และการทำงานกับอาเรย์หรือตารางตัวเลข
import pandas as pd #ไลบรารีที่ใช้สำหรับการจัดการและวิเคราะห์ข้อมูลในรูปแบบตาราง
import seaborn as sns #ไลบรารีที่ให้เครื่องมือสำหรับการทำนายและการวิเคราะห์ข้อมูลทางสถิติด้วยกราฟที่สวยงาม
import matplotlib.pyplot as plt #ไลบรารีสำหรับสร้างกราฟและแผนภาพ
# %matplotlib inline
# คำสั่งสำหรับแสดงกราฟทันทีใน Jupyter Notebook โดยไม่ต้องเรียก plt.show()

"""##Import DataSet
1.  ข้อมูลปริมาณการผลิตมังคุต (ผลผลิต)  ปี 2564 - 2565
2.  ข้อมูลปริมาณนําฝน ปี 2561-2565
3.  อุณภูมิของประเทศไทยปี 2018-2023

### ข้อมูลปริมาณการผลิตมังคุต (ผลผลิต)  ปี 2564-2565 เฉพาะ ภาคกลางกับภาคใต้

 เเหล่งที่มา: (สำนักงานเศรษฐกิจการเกษตร): https://mis-app.oae.go.th/product/%E0%B8%A1%E0%B8%B1%E0%B8%87%E0%B8%84%E0%B8%B8%E0%B8%94
# หัวข้อใน dataset
1. ปีที่บันทึกข้อมูล
2. ชื่อจังหวัด
3. ผลผลิต(ตัน)
4. สัดส่วน(ร้อยละ)
5. เนื้อที่เก็บเกี่ยว(ไร่)
6. ผลผลิตต่อเนื้อที่เก็บเกี่ยว(กก.)
"""



import folium
import geopandas as gpd
import random

# Load GeoJSON data for Thailand provinces
geojson_url = "https://gist.githubusercontent.com/jeepkd/4e31e6a10f8297b9de50c62856927ecf/raw/9899d9f1ca4cd7c5f103a9b2455d9a01f0c8f895/thailand.json"
thailand_provinces = gpd.read_file(geojson_url)

# Create a Folium map centered around Thailand
thailand_coordinates = (11.348381898597856, 99.32311640203335)
my_map = folium.Map(location=thailand_coordinates, zoom_start=8)

# Define a custom styling function with random colors
def style_function(feature):
    # Generate a random color in hex format
    random_color = "#{:06x}".format(random.randint(0, 0xFFFFFF))

    return {
        'fillColor': random_color,
        'color': "blue",
        'weight': 1,
        'fillOpacity': 0.7,
    }

# Add GeoJSON layer for Thailand provinces with custom styling
folium.GeoJson(
    thailand_provinces,
    name='geojson',
    style_function=style_function
).add_to(my_map)

# Clear previous markers
marker_group = folium.FeatureGroup(name='Markers').add_to(my_map)

# Add markers for specified provinces
locations = {
     'Bangkok': [13.7563, 100.5018],
    'Phuket': [7.8804, 98.3923],
    'Nonthaburi': [13.8563, 100.5118],
    'Pathum Thani': [14.0228, 100.5314],
    'Samut Prakan': [13.5991, 100.5968],
    'Samut Sakhon': [13.5475, 100.2733],
    'Nakhon Pathom': [13.8196, 100.0443],
    'Saraburi': [14.5290, 100.9102],
    'Lopburi': [14.8044, 100.6181],
    'Chai Nat': [15.1828, 100.1639],
    'Sing Buri': [14.8619, 100.4011],
    'Ang Thong': [14.5889, 100.4478],
    'Surat Thani': [9.1348, 99.3331],
    'Songkhla': [7.1902, 100.5793],
    'Trang': [7.5592, 99.6115],
    'Phang Nga': [8.4315, 98.5340],
    'Krabi': [8.0863, 98.9063],
    'Nakhon Si Thammarat': [8.4324, 99.9645],
    'Phatthalung': [7.6167, 100.0833],
    'Pattani': [6.8644, 101.2502],
    'Yala': [6.5394, 101.2813],
    'Narathiwat': [6.4250, 101.8253],
}

for label, location in locations.items():
    color = "yellow"  # Fixed color to red for all markers, you can customize it
    folium.Marker(location=location, popup=label, icon=folium.Icon(color=color, icon='map-marker')).add_to(marker_group)

# Add the marker group to the map
marker_group.add_to(my_map)

# Add layer control
folium.LayerControl().add_to(my_map)

# Display the map
my_map

!pip install folium

Mangosteen_production64 = pd.read_csv('https://raw.githubusercontent.com/phatt20/pro01/main/Mangosteen_production2564.csv.csv')
Mangosteen_production64.head()



Mangosteen_production65 = pd.read_csv('https://raw.githubusercontent.com/phatt20/pro01/main/Mangosteen_production.csv')
Mangosteen_production65.head()

print("Mangosteen_production shape = ", Mangosteen_production65.shape)



"""### ข้อมูลปริมาณนําฝน ปี 2561-2565
 เเหล่งที่มา : https://digi.data.go.th/showcase/thailand-rainfall-data/

# หัวข้อใน dataset
1. ProvinceID
2. ProvinceName
3. ProvinceName
4.MinRain
5.MaxRain
6.AvgRain
7.region
8.Year
9.Month
10.Date
11.Month_TH
"""

Rainfall = pd.read_csv('https://raw.githubusercontent.com/phatt20/pro01/main/rain.csv')
Rainfall.head()

print("Rainfall = ",Rainfall.shape)

"""### Cleaning data

##ผลผลิตมังคุตปี 2564-2565
"""

Mangosteen_production64.info()

Mangosteen_production65.info()

Mangosteenfinall = pd.concat([Mangosteen_production64,
                        Mangosteen_production65],
                        ignore_index=True)
Mangosteenfinall

Mangosteenfinall.rename(columns = {'จังหวัด':'ProvinceName',
                             'ผลผลิต(ตัน)':'Prod', 'สัดส่วน':'Prop',
                             'เนื้อที่เก็บเกี่ยว(ไร่)':'HarvArea',
                             'ผลผลิตต่อเนื้อที่เก็บเกี่ยว(กก.)':'ProdPerHarvArea'},
                             inplace = True)
Mangosteenfinall

Mangosteenfinall.shape

# กำจัดเครื่องหมาย (,) และเปลี่ยนชนิดข้อมูลให้เป็น float
Mangosteenfinall['Prod'] = Mangosteenfinall['Prod'].str.replace(',', '').astype(float)
Mangosteenfinall['HarvArea'] = Mangosteenfinall['HarvArea'].str.replace(',', '').astype(float)
Mangosteenfinall['ProdPerHarvArea'] = Mangosteenfinall['ProdPerHarvArea'].str.replace(',', '').astype(float)

Mangosteenfinall.dtypes

Mangosteenfinall

"""##ทำการเลือกเฉพาะ ภาคกลาง เเละ ภาคใต้"""

central_province_rows = Mangosteenfinall[Mangosteenfinall['ProvinceName'].isin(['กรุงเทพมหานคร', 'นนทบุรี', 'ปทุมธานี', 'สมุทรปราการ', 'สมุทรสาคร',
                                                                                'นครปฐม', 'สระบุรี', 'ลพบุรี', 'ชัยนาท', 'สิงห์บุรี', 'อ่างทอง', 'สุราษฎร์ธานี',
                                                                                'สงขลา', 'ตรัง', 'พังงา', 'กระบี่', 'นครศรีธรรมราช', 'พัทลุง', 'ปัตตานี',
                                                                                'ยะลา', 'นราธิวาส'])]

central_province_rows

"""## เเทนที่ค่า (Over Outlier) ด้วยค่า mean

> Indented block


"""

mean_value = central_province_rows['Prod'].mean()

central_province_rows['Prod'] = central_province_rows['Prod'].apply(lambda x: mean_value if x > 100000 or x < 1000 else x)

central_province_rows

"""##ข้อมูลอุณหภูมิประเทศไทย"""

temp001 = pd.read_csv('https://raw.githubusercontent.com/Tanthaii/Pj01/main/Temp02.csv')
temp001

"""###เลือกเฉพาะ ภาคใต้เเละกลาง

---


"""

tempselect = temp001[temp001['ProvinceName'].isin(['กรุงเทพมหานคร', 'นนทบุรี', 'ปทุมธานี', 'สมุทรปราการ', 'สมุทรสาคร',
                                                                                'นครปฐม', 'สระบุรี', 'ลพบุรี', 'ชัยนาท', 'สิงห์บุรี', 'อ่างทอง', 'สุราษฎร์ธานี',
                                                                                'สงขลา', 'ตรัง', 'พังงา', 'กระบี่', 'นครศรีธรรมราช', 'พัทลุง', 'ปัตตานี',
                                                                                'ยะลา', 'นราธิวาส'])]

tempselect

# ตัดชุดข้อมูล เอาข้อมูลตั้งแต่มี ค.ศ.2019 - 2021
tempselect_2021_2022 = tempselect[(tempselect['Year'] >= 2021) & (tempselect['Year'] <= 2022)]
tempselect_2021_2022

tempselect_2021_2022['AvgTemp'] = (tempselect_2021_2022['Tmax'] + tempselect_2021_2022['Tmin']) / 2
tempselect_2021_2022

grouped_tempall = tempselect_2021_2022.groupby(['Year','ProvinceID','ProvinceName'])['AvgTemp'].sum().reset_index()
grouped_tempall['AvgTemp'] = grouped_tempall['AvgTemp'] / 12
grouped_tempall

"""## ชุดข้อมูลปริมาณน้ำฝน"""

Rainfall.info()

# ตัดชุดข้อมูล เอาข้อมูลตั้งแต่มี ค.ศ.2019 - 2021
rainfall_data_2021_2022 = Rainfall[(Rainfall['Year'] >= 2021) & (Rainfall['Year'] <= 2022)]
rainfall_data_2021_2022

"""### รวมข้อมูลปริมาณน้ำฝนทั้งหมด เป็นรายปี

"""

grouped_rainfall = rainfall_data_2021_2022.groupby(['Year','ProvinceID','ProvinceName','region'])['AvgRain'].sum().reset_index()
grouped_rainfall['AvgRain'] = grouped_rainfall['AvgRain'] / 12
grouped_rainfall

grouped_rainfall.shape

"""##เลือกข้อมูลปริมาณนํ้าฝนเฉพาะภาคกลาง

"""

central_rain = grouped_rainfall[grouped_rainfall['ProvinceName'].isin(['กรุงเทพมหานคร', 'นนทบุรี', 'ปทุมธานี', 'สมุทรปราการ', 'สมุทรสาคร',
                                                                       'นครปฐม', 'สระบุรี', 'ลพบุรี', 'ชัยนาท', 'สิงห์บุรี', 'อ่างทอง','สุราษฎร์ธานี',
                                                                       'สงขลา', 'ตรัง', 'พังงา', 'กระบี่', 'นครศรีธรรมราช', 'พัทลุง', 'ปัตตานี',
                                                                       'ยะลา', 'นราธิวาส'])]

central_rain

"""###ผสานข้อมูลชุดนํ้าฝนกับปริมาณผลผลิตมังคุตเเละปริมาณการนําเข้า"""

central_province_rows.columns

central_rain.columns

central_rain

# รวมชุดข้อมูลโดยใช้เมธอด merge และ group ตามชื่อจังหวัด
merged_rainfall = central_rain.merge(central_province_rows, on=['ProvinceName']).merge(grouped_tempall, on=['ProvinceName'])

merged_rainfall

merged_rainfall.info()

null_counts = merged_rainfall.isnull().sum()
print(null_counts)

merged_rainfall.drop(columns=['Year_y', 'ProvinceID_y'], inplace=True)

merged_rainfall

from google.colab import files
from google.colab import drive

df = pd.DataFrame(merged_rainfall)
df.to_csv('merged_rainfall.csv', index=False)
files.download('merged_rainfall.csv')

"""#เลือก Features ที่จำเป็นในการวิเคราะห์"""

Features_= merged_rainfall[['Prod','HarvArea','AvgRain','AvgTemp']]
Features_

Features_

from scipy import stats
import numpy as np

# เมทอดในการค้นหา outliers โดยใช้ Z-score
def findOutliers(df, col, upper_threshold, lower_threshold):
    z_scores = np.abs(stats.zscore(df[col]))
    outliers = df[(z_scores > upper_threshold) | (z_scores < lower_threshold)]
    return outliers

# เมทอดในการเติมค่า null ด้วยค่าเฉลี่ยของคอลัมน์
def fillNull(df, col):
    mean_value = df[col].mean(skipna=True)
    df[col].fillna(mean_value, inplace=True)

# เมทอดในการเปลี่ยนค่าที่เกินขอบเขตเป็นค่า null (NaN)
def outlierToNull(df, col, upper_threshold, lower_threshold):
    df[col] = df[col].mask((df[col] > upper_threshold) | (df[col] < lower_threshold), np.nan)

def processData(df, col, upper_threshold, lower_threshold):
    outlierToNull(df, col, upper_threshold, lower_threshold)
    fillNull(df, col)

"""### Outlier Prod,HarvArea,AvgRain"""

Features_.head(5)

sns.boxplot(Features_['Prod'])

processData(Features_, 'Prod', 50000, 500)

"""------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"""

sns.boxplot(Features_['HarvArea'])

processData(Features_, 'HarvArea', 60000, 500)

"""--------------------------------------------------------------------------------"""

sns.boxplot(Features_['AvgRain'])

processData(Features_, 'AvgRain', 1000, 10)

sns.boxplot(Features_['AvgTemp'])

processData(Features_, 'AvgTemp', 29, 25)

Features_.head(100)



"""###4. หาความสัมพันธ์ของข้อมูลระหว่าง Features"""

Features_.corr() ##ใช้ในการคำนวณแมทริกซ์ความสัมพันธ์ (correlation matrix) ของคอลัมน์ใน DataFrame

Features_.fillna(Features_.mean(), inplace=True)

sns.heatmap(Features_.corr(), annot=True)
plt.show()

sns.pairplot(Features_,
             kind='reg',
             plot_kws={'scatter_kws': {'alpha': 0.4},
                       'line_kws': {'color': 'orange'}},
             diag_kws={'color': 'green', 'alpha':.2});

             ### ใช้ในการสร้าง "Pair Plot" หรือ Scatter Plot Matrix โดยใช้ Seaborn (sns) เพื่อแสดงการกระจายของความสัมพันธ์ระหว่างคู่คอลัมน์ที่ระบุใน DataFrame Features_. ดังนั้นเมื่อคำสั่งถูกเรียกใช้ดังนี้:

"""###5. การแบ่งชุดข้อมูลออกเป็น 2 ชุด เป็น  
*ชุดเเรก x_train เเละ y_train
*ชุดที่สอง x_value y_value
"""

from sklearn.model_selection import train_test_split
X=Features_[['HarvArea','AvgRain','AvgTemp']]  # Features
y =Features_['Prod'] # target

X

y

# แบ่งชุดข้อมูลฝึกสอน 80% และ ชุดข้อมูลทดสอบ 20%
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

"""### K-Nearest Neighbors Regression
หลักการของ KNN-R ได้แสดงดังนี้:

เลือกจำนวน K: เลือกค่า K ซึ่งเป็นจำนวนตัวอย่างที่ใช้ในการทำนายค่าต่อเนื่อง (continuous value) จากข้อมูล. ค่า K ควรถูกเลือกให้เหมาะสมโดยพิจารณาความซับซ้อนของข้อมูลและความแม่นยำที่ต้องการ.

คำนวณความคล้ายคลึง: สำหรับตัวอย่างที่ต้องการทำนาย (ตัวอย่างทดสอบ) คำนวณความคล้ายคลึง (similarity) ระหว่างตัวอย่างนี้กับตัวอย่างทุกตัวในชุดข้อมูลโดยใช้วิธีการคำนวณระยะทาง เช่น ระยะยูคลิเดียน, ระยะแมนฮัตแทน, หรืออื่น ๆ ซึ่งทำให้เราได้ระยะทางระหว่างตัวอย่างที่ใกล้ที่สุด.

เลือกตัวอย่าง K ตัวที่คล้ายที่สุด: เลือก K ตัวอย่างที่คล้ายที่สุดกับตัวอย่างทดสอบ โดยเรียงตัวอย่างตามความคล้ายคลึงจากต่ำไปสูง และเลือก K ตัวอย่างแรก.

คำนวณค่าทำนาย: สำหรับการ Regression (ทำนายค่าต่อเนื่อง), เราจะคำนวณค่าเฉลี่ยของค่าตัวแปรตามของ K ตัวอย่างที่ถูกเลือกมา. ค่าเฉลี่ยนี้จะเป็นค่าทำนายสำหรับตัวอย่างทดสอบ.

ทำนายค่า: ใช้ค่าทำนายที่คำนวณไว้ในขั้นตอนที่ 4 เพื่อทำนายค่าต่อเนื่องสำหรับตัวอย่างทดสอบ.

ค่าทำนาย: ค่าทำนายคือค่าต่อเนื่องที่ได้จากขั้นตอนที่ 5 และเป็นค่าที่คำนวณขึ้นโดยใช้ข้อมูลในชุดข้อมูล ซึ่งใช้ในการทำนายค่าต่อเนื่องสำหรับตัวอย่างทดสอบ.

KNN-R นี้เป็นวิธีง่าย ๆ และสมเหตุสมในการทำนายค่าต่อเนื่อง และความคล้ายคลึงเป็นแนวคิดหลักในการทำนาย ซึ่งอาจใช้ได้ในหลายงานอย่างกว้างขวาง เช่น การทำนายราคาบ้าน, การทำนายยอดขายสินค้า, หรือการทำนายค่าหุ้น เป็นต้น.
"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn import preprocessing

scaler = preprocessing.MinMaxScaler()
scaler.fit(X_train)

X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)
#โมดูล preprocessing จาก scikit-learn เพื่อทำการปรับค่าข้อมูลให้อยู่ในช่วงที่กำหนดโดยใช้ MinMaxScaler ซึ่งจะปรับค่าข้อมูลให้อยู่ในช่วง 0 ถึง 1 โดยทำการลบค่าข้อมูลด้วยค่าของค่าน้อยสุดและนำค่าน้อยสุดออกหารด้วยความแตกต่างระหว่างค่ามากสุดกับค่าน้อยสุดของข้อมูลที่เป็นไปได้ในแต่ละคอลัมน์
#สามารถลดค่าความคลาดเคลื่อนลงได้ดีขึ้น

# เติมค่าเฉลี่ยให้กับแถวที่มีค่า NaN ใน y_train
mean_value = y_train.mean()
y_train.fillna(mean_value, inplace=True)

X_train_scaled

X_test_scaled

knnr = KNeighborsRegressor(n_neighbors = 8, metric='euclidean')
knnr.fit(X_train, y_train)

from sklearn.metrics import mean_squared_error

fig, ax = plt.subplots(figsize=(8,5))
k_list = np.arange(1, 9, 1)
knn_dict = {} # To store k and mae pairs
for i in k_list:
#Knn Model Creation
    knn = KNeighborsRegressor(n_neighbors=int(i))
    model_knn = knn.fit(X_train_scaled, y_train)
    y_knn_pred = model_knn.predict(X_test_scaled)
#Storing MSE
    mse = mean_squared_error(y_test, y_knn_pred)
    knn_dict[i] = mse
#Plotting the results
ax.plot(knn_dict.keys(),knn_dict.values())
ax.set_xlabel('K-VALUE', fontsize=16)
ax.set_ylabel('MSE' ,fontsize=16)
ax.set_title('ELBOW PLOT' ,fontsize=20)

for i in range(1, min(len(X_train_scaled), len(X_test_scaled)) + 1):
    knn = KNeighborsRegressor(n_neighbors=i)
    model_knn = knn.fit(X_train_scaled, y_train)
    y_knn_pred = model_knn.predict(X_test_scaled)
    mse = mean_squared_error(y_test, y_knn_pred)
    # เก็บ MSE หรือทำอะไรก็ตามที่คุณต้องการทำต่อ



"""###  การพยากรณ์ (Predictions)

(Training Set)
"""

y_pred_train = knnr.predict(X_train)
y_pred_train

"""(Test Set)"""

y_pred_test = knnr.predict(X_test)
y_pred_test

y_pred = knnr.predict(X)
y_pred

y

"""ชุดข้อมูล X (train+test)"""

Features_['Predicted_Prod'] = knnr.predict(X)
Features_

absolute_dis_list = abs(y_pred - Features_['Prod'])
result_df_knnr = pd.DataFrame({'y_pred': y_pred, 'absolute_difference': absolute_dis_list})
result_df_knnr['Real_Prod'] = y



result_df_knnr

plt.figure(figsize = (8, 5))
plt.plot(y_pred, label = 'Predicted Change',
         linestyle="--", marker='o', color='orange') # การเปลี่ยนแปลงที่คาดการณ์ไว้
plt.plot(Features_['Prod'], label = 'Real Change',
         linestyle="--", marker='o', color='grey') # การเปลี่ยนแปลงที่แท้จริง
plt.legend()

"""\###การประเมินผลโมเดล (Model Evaluation)

**ชุดข้อมูลฝึกฝน (Training Set)**
"""

KNNR_report = evaluate_model(y_train, y_pred_train, 'K-Nearest Neighbors Regression')
#ประเมินประสิทธิภาพของโมเดล K-Nearest Neighbors Regression (KNNR) ได้

#โดยปกติแล้วฟังก์ชัน evaluate_model จะใช้ค่าจริงและค่าทำนายเพื่อคำนวณค่าผลลัพธ์ที่เกี่ยวข้องกับประสิทธิภาพของโมเดล เช่น ค่า MSE (Mean Squared Error), RMSE (Root Mean Squared Error), MAE (Mean Absolute Error),

plt.scatter(y_pred_train, y_train)

plt.plot(y_pred_train, y_pred_train, color='red')

plt.title('Scatter Plot between Predicted & Actual Values')
plt.xlabel('Predicted')
plt.ylabel('Actual')
##Scatter Plot จะช่วยในการดูความสัมพันธ์ระหว่างค่าที่ทำนายได้จากโมเดลกับค่าจริงของข้อมูล ถ้าข้อมูลต่าง ๆ ตกลงบนเส้นสีแดง หมายความว่าโมเดลทำนายได้ถูกต้องอย่างสมบูรณ์

"""**ชุดข้อมูลทดสอบ (Test Set)**"""

evaluate_model(y_test, y_pred_test, 'K-Nearest Neighbors Regression')

plt.scatter(y_pred_test, y_test)

plt.plot(y_pred_test, y_pred_test, color='red')

plt.title('Scatter Plot between Predicted & Actual Values')
plt.xlabel('Predicted')
plt.ylabel('Actual')

"""### Multiple Linear Regression

สร้างโมเดล (Create Model)
"""

from sklearn.linear_model import LinearRegression

reg = LinearRegression()
reg.fit(X_train, y_train)

# ค่าจุดตัดแกน Y ของสมการ
reg.intercept_

# ค่าสัมประสิทธิ์การถดถอยของตัวตอบสนอง X
reg.coef_

"""###(Predictions)

**ชุดข้อมูลฝึกฝน (Training Set)**
"""

y_pred_train = reg.predict(X_train)
y_pred_train

"""**ชุดข้อมูลทดสอบ (Test Set)**"""

y_pred_test = reg.predict(X_test)
y_pred_test

"""**ชุดข้อมูล X (train+test)**"""

y_pred = reg.predict(X)
y_pred

absolute_dis_list = abs(y_pred - Features_['Prod'])
result_df_mlr = pd.DataFrame({'y_pred': y_pred, 'real_df_prod': Features_['Prod'], 'absolute_difference': absolute_dis_list})

result_df_mlr

plt.figure(figsize = (8, 5))
plt.plot(y_pred, label = 'Predicted Change', linestyle="--", marker='o', color='orange') # การเปลี่ยนแปลงที่คาดการณ์ไว้
plt.plot(Features_['Prod'], label = 'Real Change', linestyle="--", marker='o', color='grey') # การเปลี่ยนแปลงที่แท้จริง
plt.legend()

"""###  การประเมินผลโมเดล (Model Evaluation)

**ชุดข้อมูลฝึกฝน (Training Set)**
"""

MLR_report = evaluate_model(y_train, y_pred_train, 'Multiple Linear Regression')

plt.scatter(y_pred_train, y_train)

plt.plot(y_pred_train, y_pred_train, color='red')

plt.title('Scatter Plot between Predicted & Actual Values')
plt.xlabel('Predicted')
plt.ylabel('Actual')

"""**ชุดข้อมูลทดสอบ (Test Set)**"""

evaluate_model(y_test, y_pred_test, 'Multiple Linear Regression')

plt.scatter(y_pred_test, y_test)

plt.plot(y_pred_test, y_pred_test, color='red')

plt.title('Scatter Plot between Predicted & Actual Values')
plt.xlabel('Predicted')
plt.ylabel('Actual')

"""#บทสรุปสุดท้ายและการเปรียบเทียบ"""

plt.figure(figsize = (8, 5))
plt.plot(result_df_knnr['y_pred'], label = 'KNNR prediction', linestyle="-.",marker='o', color='green') # การเปลี่ยนแปลงที่คาดการณ์ไว้
plt.plot(result_df_mlr['y_pred'], label = 'MLR prediction', linestyle="-.",marker='o', color='red') # การเปลี่ยนแปลงที่แท้จริง)
plt.plot(Features_['Prod'], label = 'Real value', linestyle="-", marker='o', color='grey') # การเปลี่ยนแปลงที่แท้จริง)
plt.legend()

KNNR_report['modelName']

def print_rep(report) :
  print('Model :', report['modelName'])
  print('R2 :', round(report['r2'], 2))
  print('MSE :', round(report['mse'], 2))
  print('RMSE :', round(report['rmse'], 2))

print_rep(KNNR_report)
print('--------------------------------------')
print_rep(MLR_report)

# ตัวอย่างการคำนวณค่าประสิทธิภาพโดยรวม
r2_knn = 0.34
mse_knn = 3390341.83
rmse_knn =  1841.29

r2_mlr = 0.03
mse_mlr = 5003833.85
rmse_mlr = 2236.93

# คำนวณค่าประสิทธิภาพโดยรวมตามต้องการ (ตัวอย่าง: เฉลี่ย)
overall_performance_knn = (r2_knn + (1 / mse_knn) + (1 / rmse_knn)) / 3
overall_performance_mlr = (r2_mlr + (1 / mse_mlr) + (1 / rmse_mlr)) / 3

print("Overall Performance - KNN:", round(overall_performance_knn, 2))
print("Overall Performance - MLR:", round(overall_performance_mlr, 2))